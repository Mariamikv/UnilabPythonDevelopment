# შაბლონების გამოყენება + [Jinja](#jinja)
_[Templates](https://flask.palletsprojects.com/en/1.1.x/tutorial/templates/#templates)_ ანუ შაბლონები წარმოადგენენ სტატიკურ ინფორმაციას და გამოყოფილ ადგილებს (placeholders) დინამიური ინფორმაციისათვის.

## შესავალი
ამ ეტაპაბამდე ვნახეთ როგორ შეიძლება წინასწარ გაწერილი სტატიკური HTML კოდის ბრაუზერში გამოჩენა python-ის ბიბლიოთეკა Flask-ის გამოყენებით.
რეალურად html გვერდის გამოსაჩენად უნდა დავუკავშირდეთ view ფუნქციას, რომ შევძლოთ წინასწარ გამზადებულ HTML შაბლონთან მუშაობა.
ამ რიგად ჩვენ შევძლებთ სტატიკური გვერდის შაბლონში დინამიურად ინფორმაციის მიმოცვლას მომხმარებელსა და სერვერს შორის.

Flask-ი გაშვებისას ავტომატურად იპოვის HTML ფაილებს განთავსებულს _**/templates** დირექტორიაში_

## სარჩევი
- [შესავალი](#შესავალი)
- [/static - ბინა სტატიკური ფაილებისთვის](#/static)
- [``render_template()`` - შაბლონის რენდერი](#შაბლონის-რენდერი)
  - [render_template() გამოყენების მაგალითი / მინიმალური კოდი](#render_template-გამოყენების-მაგალითი)
- [Jinja](#jinja) 
  - [სადემონსტრაციო მაგალითი](#jinja-ს-გამოყენების-მაგალითი-html-თან)
  - [ენის სტრუქტურა და ანატომია](#ენის-ანატომია)
- [Template Inheritance](#template-inheritance)
## /static
როგორც შევთანხმდით დინამიური ვებ აპლიკაციის შემადგენელ ელემენტებში სედის სტატიკური რესურსებიც. სტატიკურ რესურსებად შეგვიძლი განვიხილოთ
ვებ აპლიკაციის მუშაობაში ჩართული ყველა ის ელემენტი რომელიც მუშაობის პროცესში არ იცვლება, მაგალითად: ვებ გვერდის შემადგენელი სურათები, სტილური ფაილი, ჯავასკრიპტ კოდი და ა.შ.
სწორად გამართული ვებ სერვერი ავტომატურად პოულობს ამ ფაილებს და იყენებს როგორც სტატიკურ რესურსებს, თუმცა დეველოპმენტ პროცესშ ამ საფეხურის გავლა ხელით შეგვიძლია.
ამისთვის უბრალოდ უნდა შექმნა დირექტორია /static სადაც შეძლებ იმ სტატიკური ფაილების მოთავსებას რომლის პროექტში გამოყენებასაც გეგმავ.

სტატიკური ფაილების მისამართის დასაგენერირებლად შეგიძლია გამოიყენო url_for ფუნქცია:

````python
url_for('static', filename='style.css')
````

ეს მაგალითი დააგენერეირებს მისამართს static/style.css ფაილისთვის.


  
## [შაბლონის რენდერი ](https://flask.palletsprojects.com/en/1.1.x/quickstart/#rendering-templates)
წინა თავში გარჩეული მეთოდის გამოყენებით HTML-ის python-ის კოდიდან დარენდერება არც პრაქტიკული მეთოდია, რადგან html სინტაქსთან მორგება საკმაოდ დამღლელი პროცედურა იქნება და არც კოდის მხრივ ვიზუალურად მისაღები.
სტატიკური html ფაილის რენდერის საუკეთესო გზა არის flask-იდან render_template მეთოდის გამოყენება და .html ფაილის view ფუნქციიდან გამოტანა.

გვერდის გამოსაჩენად კი მხოლოდ html შაბლონის დასახელების/მისამართის და საჭიროების შემთხვევასი ცვლადების მნიშვნელობის მითითება იქნება საჭირო:

### render_template გამოყენების მაგალითი
```python
from flask import render_template

@app.route('/about')
def about():
    return render_template('about.html',)
``` 

Flask-ი ავტომატურად იპოვის templates დირექტორიაში არსებულ about.html ფაილს და დაგვიბრუნებს გვერდის რენდერს შესაბამის მარშუტზე მოთხოვნის გაგზავნისას.


## [Jinja](https://jinja.palletsprojects.com/en/2.11.x/)
შაბლონთან სამუშაო ენა

![jinja pic](https://jinja.palletsprojects.com/en/2.11.x/_images/jinja-logo.png)

Flask-ი შაბლონებში დინამიური ელემენტების ჩასატვირთად იყენებს [Jinja](https://jinja.palletsprojects.com/en/2.11.x/) -ს ბიბლიოთეკას.
ის თანამედროვე, მარტივად გამოსაყენებელი შაბლონთან სამუშაო ენაა, შექმნილი [Djano-ს შაბლონების](https://docs.djangoproject.com/en/3.1/topics/templates/#:~:text=A%20Django%20template%20is%20a,is%20rendered%20with%20a%20context.) პრინციპზე.
მისი სისწრაფის და უსაფრთხოების გამო ის აქტიურად გამოიყენება ფლასკზე აწყობილ ვებ სერვისებში.

ჯინჯას დახმარებით ჩვენ შევძლებთ პითონიდან შაბლონს გადავცეთ სტრინგები, სიები, ლექსიკონები და სხვადასხვა ტიპის მონაცემები წინასწარ გამზადებულ შაბლონებს.



### ენის ანატომია
როგორც შევთანხმდით შაბლონური ენები შეიცავენ კოდის სტატიკურ ანუ უცვლელ და დინამიურ ანუ ცვლად ელემენტებს. ცვლადი ელემენტი შეიძლება იყოს
როგორც ცვლადი ასევე პროგრამული ლოგიკა რომელის მუშაობითაც შექმნილი მნიშვნელობა ჩნდება შაბლონში შესაბამისი ფლეისჰოლდერის ნაცვლად.
სინტაქსურად jinja იყენებს ორ ძირითად აღნიშვნას ცვლადები/ლოგიკისთვის და მნიშვნელობის გამოსატანად. ეს აღნიშვნები კოდში გამოიყენება როგორც თეგები, დელიმიტერები.

თეგი/დელიმიტერი | აღწერა
--- | ---
[`{% ... %}`](https://jinja.palletsprojects.com/en/2.11.x/templates/#list-of-control-structures) | გამოიყენება პირობის ან ლოგიკის გასაწერად (მაგალითად ლუპების)
[`{{ ... }}`](https://jinja.palletsprojects.com/en/2.11.x/templates/#expressions) | გამოიყენება მნიშვნელობის შაბლონში გამოყოფილ ადგილას გამოსატანად.
[`{# ... #}`](https://jinja.palletsprojects.com/en/2.11.x/templates/#comments) | გამოიყენება ფაილში კომენტარის დასამატებლად რომელიც არ გამოჩნდება რენდერისას

> შეჯამება: Jinja-ს შაბლონი .html ფორმატის ფაილი რომელიც ვებ გვერდის შაბლონში დინამიური ელემენტების განთავსებაში გვეთხმარება.
> შეთანხმების თანახმად, flask-ის პროექტისთვის jinjaს ფაილები თავსდება /templates დირექტორიაში.
> მისი მუშაობის პრინციპი წააგავს სტრინგ ფორმატინგით მუშაობას, თუმცა შაბლონური ენები დამატებით შესაძლებლობას გვაძლევს HTML ფაილში პროგრამის ლოგიკის დატანის..

### Jinja-ს გამოყენების მაგალითი
[ავაწყოთ ჯინჯას ფაილი](https://jinja.palletsprojects.com/en/2.11.x/templates/) html-ის დახმარებით და დავაკავშიროთ flask აპლიკაციასთან

#### Python-ს მხარეს
ფლასკში ჯინჯას ფაილის რენდერი

````python
from flask import render_template

@app.route('/hello/<name>')
def hello(name):
    return render_template('hello.html', name=name, my_list = ["ელემენტი 1", "ელემენტი 2", "ელემენტი 3"])
````

#### Jinja-ს მხარეს
ჯინჯას დახმარებით აწყობილი hello.html ფაილი
```jinja2
<!doctype html>
<title>შაბლონური Jinja-ს ფაილი</title>
{% if name %}
  <h1>მოგესალმები {{ name }}!</h1>
{% else %}
  <h1>გამარჯობა მომხმარებელო!</h1>
{% endif %}
<ul>
    {% for n in my_list %}
        <li>{{n}}</li>
    {% endfor %}
</ul>
```

შესაბამისად render_template ფუნქციისათვის გადაცემული პარამეტრები ხდება გამოყენებადი ჯინჯას შაბლონში, როგორც პროგრამული ლოგიკის ასაწყობად ისე მონაცემთა შაბლონში გამოსაჩენად.

### [Control Structures]
Control Structures ეწოდება კოდის იმ ელემენტს რომელიც პროგრამის შესრულების ლოგიკის დინებას მართავს. Pythonდან უკვე ვიცით რამოდენიმე მსგავსი ელემენტი
მაგალითად if/elif/else პირობები, for და while ლუპები. ჯინჯასთან მუშაობისას ძირითადად გამოვიყენებთ ორ ძირითად სტრუქტურას: [if-statements](https://jinja.palletsprojects.com/en/2.11.x/templates/#if) და [for-loops](https://jinja.palletsprojects.com/en/2.11.x/templates/#for).

მიუხედავად იმისა რომ სინტაქსით jinja წააგავს python-ს, გაითვალისწინეთ რომ კოდის ბლოკის საზღვრები ყოველთვის უნდა გაწეროთ, პირობის ან ლუპის დასასრულს, ბლოკის ბოლოს შესაბამისი თეგით 

მაგალითად: 

````jinja2
{% if statement %}
  <h1>ჭეშმარიტი პირობა!</h1>
{% else %}
  <h1>მცდარი პირობა!</h1>
{% endif %}
````

## Template Inheritance
Jinja-ს ერთ-ერთი უძლიერესი მხარეა შაბლონის template inheritance. შაბლონის ინჰერენტულობა გვაძლევს შესაძლებლობას შევქმნათ საბაზისო ჩონჩხური შაბლონი რომელიც თავის თავში მოიცავს ვებ გვერდის ასაშენელად განკუთვნილ ყველა ბლოკს და შემდგომ ჩავაშენოთ კონკრეტული ელემენტები ვებ გვერდში.

![Template Inheritance](base.png)

ვებგვერდების აწყობისას შეამჩნევთ რომ საიტზე განთავსებული გვერდები იზიარებენ მსგავს ელემენტებს. მაგალითად, როგორც წესი, ნავიგაციის პანელი ყველა გვერდისთვის საერთოა, ისევე როგორც ფუტერი. 
იმისთვის რომ ერთი და იგივე ელემენტების გაწერა რამდენჯერმე არ დაგვჭირდეს შაბლონის შექმნისას, გამოვიყენებთ ჯინჯას შაბლონის ინჰერენტულობის მეთოდს.

ამისთვის ჯერ შევქმნით საბაზისო ფაილს basic.html რომელიც შეიცავს საიტის რამდენჯერმე გამოყენებად ელემენტებს, ხოლო შემდგომ მას გამოვიყენებთ კონკრეტულ გვერდზე ჩასაშენებლად `{% extend "base.html" %}` და `{% block %}` სინტაქსის გამოყენებით.

### base.html საბაზისო შაბლონი
საბაზისო შაბლონში ავაწყობთ გვერდის ძირითად განლაგებას და გავწერთ თუ სად უნდა მოთავსდეს უშუალოდ ჩატვირთული გვერდის კონტენიტ:

````jinja2
<div class="container">
      <h2>საბაზისო შაბლონის ნაწილი</h2>
      <br>
      {% block content %}{% endblock %}
      <br>
      <h2>საბაზისო შაბლონის ნაწილი</h2>
</div>
````

### page 

````jinja2
{% extends "base.html" %}
{% block content %}

<title>მოთხოვნილი გვერდის შიგთავსი</title>

{% endblock %}
````

## დამატებითი რესურსები
- https://realpython.com/primer-on-jinja-templating/
- https://jinja.palletsprojects.com/en/2.11.x/templates/
