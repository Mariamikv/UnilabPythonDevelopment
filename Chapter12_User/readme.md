# მომხმარებელი

## შესავალი

ამ დრომდე ჩვენს მიერ შექმნილ ყველა რესურსზე ღია წვდომა გვაქვს. ეს ნიშნავს რომ ნებისმიერი ვებ გვერდის თუ API-ს ფუნქციონალის ნახვა და გამოყენება ყველასთვის ღიაა. ხშირ შემთხვევაში კი გვჭირდება რომ გარკვეული ფუნქციონალი მხოლოდ რეგისტრირებული მომხმარებლისთვის გამოვაჩინოთ. შესაძლებელია რეგისტრირებული მომხმარებლებიც დავყოთ ქვეჯგუფებად და მივანიჭოთ მათ შესაბამისი პრივილეგიები და შესაძლებლობები. 

ამ თავის ძირითადი მისანია გავეცნოთ მომხმარებლის ავტორიზაციას და აუთენტიფიკაციას. პროცესში ვისწავლით პაროლის ჰაშირებას, ფლასკის აუტორიზაციის და აუტენთიფიკაციის ბიბლიოთეკების გამოყენებას.

## მომხმარებლის ავტორიზაცია და პაროლი

თუ საიტზე ვაპირებთ ავტორიზაციის ჩაშენებას ეს ნიშნავს, რომ მომხმარებელს შესაძლებლობას ვაძლევთ გაიაროს რეგისტრაცია და შექმნას თავისი ციფრული ანგარიში, რომელიც იქნება პერსონალურად მისი და რომლის დახმარებითაც შეძლებს გარკვეულ პროცესებზე მოიპოვოს წვდომა.

იმისთვის რომ მომხმარებლის ანგარიში დავიცვათ და ანგარიშის მართვაზე მხოლოდ მომხმარებელს ჰქონდეს წვდომა, საჭიროა გარკვეული ავტორიზაციის ფორმის გამოყენება. ყველაზე გავრცელებული ფორმა მომხმარებლის **უნიკალური იდენტიფიკატორისა** და მხოლოდ მისთვის ცნობილი **პაროლის** გამოყენებით ავტორიზაცია. ამ პროცესს log in ანუ შესვლის ფორმის გავლით გავდივართ.

ფორმაში შევსებული მონაცემის გადასამოწმებლად აუცილებელია სერვერის მხარესაც გვქონდეს შენახული მომხმარებლის მიერ რეგისტრაციის დროს არჩეული **იდენტიფიკატორი** (ხშირ შემთხვევაში *username*-მომხმარებლის სახელი) და პაროლი (password). რადგან მომხმარებლის პაროლი ერთ-ერთი ყველაზე ფაქიზი მონაცემია რაც მომხმარებლის მთელს ანგარიშზე წვდომის მოსაპოვებლად გამოიყენება, აუცილებელია მისი დაცვა შევძლოთ, იმ შემთხვევაშიც კი თუ ვინმე ჩვენი მონაცემთა ბაზიდან მონაცემის ამოღებას შეძლებს. შესაბამისად, უსაფრთხოების მიზნებისთვის, არასდროს არ უნდა შევინახოთ ტექსტი პირდაპირი სახით, იმ სტრინგად როგორც ის მომხმარებელმა შეავსო. 

ინფორმაციის დასაშიფრად შეგვიძლია გამოვიყენოთ **hash** ფუნქცია. ჰაშირება ნიშნავს ისეთი ალგორითმის გამოყენებას, რომელიც იღებს დოკუმენტს (ჩვენს შემთხვევაში პაროლის შიგთავსს) და უკან გვიბრუნებს უსაფრთხოდ დაშიფრულ ფაილს. ჰაშირებული ფაილი უსაფრთხოა რადგან ადამიანისთვის ამგვარი ფაილის შიგთავსი არაინტორმატიულია. საბედნიეროდ უკვე არსებობს ჰაშირების უამრავი სხვადასხვა ალგორითმი და ბიბლიოთეკა რომლის გამოყენებაც პროექტში შეგვიძლია.

შესაბამისად ჩვენ ჰაშირების ფუნქციის გამოყენებით დავშიფრავთ რეგისტრაციის დროს მომხმარებლის მიერ შეყვანილ პაროლს და ისე მოვათავსებთ მონაცემთა ბაზაში. მომხმარებლის ყოველი ავტორიზაციისას შეყვანილ პაროლსაც ანალგური ალგორითმით გავუკეთებთ ჰაშირებას და შევადარებთ მომხმარებლის იდენტიფიკატორის გასწვრივ დამახსოვრებულ ჰაშირებულ პაროლს. დამთხვევის შემთხვევაში შეგვიძლია ჩავთვალოთ რომ მომხმარებელმა ავტორიზაცია წარმატებით გაიარა.

ამისთვის ორი საკმაოდ გამოსადეგი ბიბლიოთეკები გვაქვს პითონ გარემოში, ჩვენ მათგან ორს განვიხილავთ. ესენია:

- Bcrypt
- Werkzeug

ორივე საკმაოდ პოპულარულია, ხშირად გამოიყენება Flask აპლიკაციებში და საკმაოდ ჰგავს ერთმანეთს. ასე რომ არჩევანი თქვენზეა, თუ რომელს გამოიყენებთ საბოლოოდ პროექტში.

## Bcrypt

<img src="https://i.ytimg.com/vi/r1Iygf-rRdE/maxresdefault.jpg" alt="Argon2 Password Hashing Node.js | BCrypt Alternative - YouTube" style="zoom:20%;" />

*bcrypt* არის პაროლის ჰაშირების ფუნქცია რომელიც Niels Provos და David Mazières დიზაინის მიხედვით შეიქმნა და გამოსაყენებლად 1999 გამოჩნდა, თუმცა დღემდე საკმაოდ აქტიურად გამოიყენება. მისი გამოყენება შესაძლებელია პითონის აპლიკაციებშიც, შესაბამისი ბიბლიოთეკის დაყენების შემდგომ:

```bash
pip install bcrypt
```

თუმცა ჩვენ გამოვიყენებთ უშუალოდ Flask-ზე ოპტიმიზირებულ ვერსიას, რომელსაც იოლად ჩავაშენებთ ჩვენს flask აპლიკაციაში:

```
 pip install flask-bcrypt
```

პროექტში შემოსატანად კი დგვჭირდება შემდეგი პითონის ინსტრუქციის გაწერა:

```python
from flask_bcrypt import Bcrypt
```

პროექტში Bycrpt-ის გამოსაყენებლად უნდა შევქმნათ შესაბამისი ჰეშერ ობიექტი. მისი დახმარებით შევძლებთ ნებისმიერი მონაცემის ჰაშირებას. ჰაშირების პროცესში დაგვეხმარება `generate_password_hash(password='string_to_hash')` მეთოდი.

მაგალითად:

```python
from flask_bcrypt import Bcrypt

bcrypt = Bcrypt()

password = "bestkeptsecret"

hashed_pass = bcrypt.generate_password_hash(password=password)

print(f'Hashed_Pass: {hashed_pass}')
```

დაგვიბრუნებს სტრინგის ჰაშირებულ ვერსიას:

` Hashed_Pass: b'$2b$12$m3DOb4ospynwqO.TEb6bHeJh3nWgenyRjpDA6LstfsjoOBpVzW3HG' `

ამრიგად დაშიფრული პაროლის შენახვა უკვე შესაძლებელია ბაზაში, რადგან როგორც ხედავთ ის ადამიანისთვის აბსოლუტურად არაინფორმატიულია.

მომხმარებლის მიერ შეყვანილი პაროლის გადასამოწმებლად, ისევ Bcrypt ბიბლიოთეკიდან გამოვიყენებთ `check_password_hash(hashed_pass, 'user_typed_password')`.  როგორც ხედავთ მეთოდს არგუმენტებად უნდა გადავცეთ შესადარებელი პარამეტრები. მეთოდი უკან დაგვიბრუნებს True/False მნიშვნელობებს იმის მიხედვით სწორია თუ არა მომხმარებლის შეყვანილი მონაცემი.

სრული რეფერენსისთვის ნახეთ [**მაგალითი**](/Chapter12_User/examples/bycrpt.py)

## Werkzeug

*werkzeug* German noun: “tool”. Etymology: *werk* (“work”), *zeug* (“stuff”)

![Werkzeug — Werkzeug Documentation (1.0.x)](https://werkzeug.palletsprojects.com/en/1.0.x/_static/werkzeug.png)

Werkzeug-ის გამოყენებაც იდენტურად ხდება. თუ ამ ეტაპზე არ გაქვთ ბიბლიოთეკა შეგიძლია გადმოწეროთ მენეჯერის დახმარებით:

`pip install Werkzeug` 

Werkzeug ხელსაწყოების ნაკლებია რომელიც იდეალურად მუშაობს Flask-თან ერთად, რადგან არ იყენებს გარე ბიბლიოთეკებს. 

ჩვებ განივუტებევთ მის secureity ნაკრებიდან პაროლის ჰაშირების ხელსაწყოებს: `generate_password_hash` და `check_password_hash`.

`from werkzeug.security import generate_password_hash, check_password_hash`

მნიშვნელოვანი განსხვავება `bcrypt`-ისგან არის რომ არ გვჭირდება დამატებითი ობიექქტის შექმნა ჰაშირების მეთოდების გამოსაყენებლად. ბიბლიოთეკიდან პირდაპირ შემოგვაქვს მეთოდები რომელიც ფუნქციისამებრ შეგვიძლია გამოვიყენოთ.

მაგალითად:

### პაროლის ჰაშირებისთვის

```python
hashed_pass = generate_password_hash('bestkeptsecret')
print(hashed_pass)
```

`Hashed_Pass: pbkdf2:sha256:150000$oFv3Q4NF$fe102689242d740cca5f1cd100c9bb3c31051c63a8df817f9a76dd26c49b6ceb`

### პაროლის შესამოწმებლად

```python
check = check_password_hash(hashed_pass, 'bestkeptsecret')
print(f'Result: {check}')
```

`Result: True`



## Flask-Login

`flask-login` არის ფლასკის დამატებითი ბიბლიოთეკა, რომელიც მომხმარებლის პროფილზე "შესვლის"/აუტენთიფიკაციის ფუნქციონალის ვებ აპლიკაციაში ჩაშენების საფეხურს გვიმარტივებს.  ის შედგება მარტივად გამოსაყენებელი დეკორეატორებისგან რომელიც მომხმარებლის ფუნქციონალის აწყობას გვიმარტივებს.

დემონსტრაციისთვის ავაწყოთ ახალი აპლიკაცია. შესაბამისი სტრუქტურით:

```
FlaskApp
|____ myproject
|____ app.py
```

გაითვალისწინეთ, აპლიკაცია და პროექტის საქაღალდე ერთ დონეზეა.

myproject-ში დაგვჭირდება შესაბამისი ფაილების დამატება:

```
myproject
|____ __init__.py
|____ forms.py
|____ modules.py
|____ templates
     |____ base.html
     |____ home.html
     |____ login.html
     |____ register.html
     |____ welcome_user.html

```

### `__init__.py`

როგორც შევთანხმდით აქ ავაწყობთ აპლიკაციას და მის კონფიგურაციას

``` python
import os
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from flask_migrate import Migrate
from flask_login import LoginManager


# Create a login manager object
login_manager = LoginManager()

app = Flask(__name__)

# Often people will also separate these into a separate config.py file
app.config['SECRET_KEY'] = 'mysecretkey'
basedir = os.path.abspath(os.path.dirname(__file__))
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
Migrate(app,db)

# We can now pass in our app to the login manager
login_manager.init_app(app)

# Tell users what view to go to when they need to login.
login_manager.login_view = "login"

```

