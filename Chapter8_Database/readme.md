# მონაცემთა საცავი 
ამ თავში გავივლით შესავალს მონაცემთა ბაზებში პითონის გამოყენებით და ვნახავთ როგორ დავაკავშიროთ ბაზა Flask-ის აპლიკაციასთან

## სარჩევი
- [შესავალი](#შესავალი)
    - [SQL - Structured Query Language](#sql)
    - [ცხრილები](#ცხრილები)
- [SQLite3](#sqlite)
- [Flask კონფიგურირება ბაზისთვის](#flask-და-მონაცემთა-ბაზა)
    - [მინიმალური მაგალითი](#მინიმალური-მაგალითი)
    - [Flask-ის კონფიგურირება მონაცემთა ბაზისთვის](#flask-აპლიკაციის-გამართვა)
    - [ბაზის მოდელის აწყობა ფლასკში](#ბაზის-მოდელის-აწყობა)
## შესავალი
ამ ეტაპისთვის უკვე ვიცით თუ როგორ შეგვიძლია მომხმარებლისგან ავიღოთ და დავამუშავოთ მონაცემები. ახლა ჩვენი მიზანია ვისწავლოთ
როგორ შეიძლება მონაცემებს სტრუქტურიზაცია და შენახვა.

Მონაცემთა ბაზა (database) არის ინფორმაციის მოწესრიგებული, დალაგებული კრებული, რომელში შემავალი მონაცემების მართვა, წაკითხვა, ამოღება, დამატება და განახლება გვეხმარება მარტივად გავზარდოთ ჩვენი პროგრამის ფუნქციონალური შესაძლებლობები. 

მონაცემთა ბაზა არის საცავი, დახარისხებული ინფორმაციის საწყობი. არსებობს მონაცემთა ბაზის სხვადასხვა ტიპი, თუმცა ჩვენი სწორება იქნება რელაციურ SQL ტიპის მონაცემთა ბაზაზე.

**Რელაციური მონაცემთა ბაზა** არის მონაცემთა ბაზის ერთ-ერთი ტიპი. Მასში იმფორმაცია ისეა დალაგებული რომ მარტივად შევძლოთ მონაცემის იდენტიფიცირება და მასზე წვდომა, მასში შემავალ მონაცემთან მიმართებაში. 
Ხშირ შემთხვევაში, რელაციური ბაზაში, მონაცემები ინახება ცხრილების სახით.

### ცხრილები
ცხრილი არის ერთეული ობიექტი რომელიც ინახავს მონაცემს რელაციურ მონაცემთა საცავში. მონაცემთა საცავი შეიძლება მოიცავდეს ერთ ან მეტ ცხრილს.

ცხრილი კი თავის თავში შედგება სვეტებისა და სტრიქონებისგან (columns/rows). ყოველ სტრიქონს აქვს განსაზღვრული დასახელება და ინფორმაციის ტიპი
რომელიც მის გასწვრივ სტრიქონებში განთავსდება.

![ცხრილი](https://www.sqlshack.com/wp-content/uploads/2020/07/anatomy-of-a-sql-table-1.png)

სურათზე არის რელაციური SQL ბაზის მარტივი მაგალითი, სადაც ცხრილი **Persons** შედგება **Id**, **Name**, **SurName** და **age** სვეტებისგან. სვეტებში შემავალი ინფორმაცია, განლაგებული მწკრივბად განსხვავდება შიგთავსითა და ტიპი, ზოგიერთი მათგან ტექსტური, ხოლო ზოგი რიცხვითი სახისაა.

### SQL 
**Structured Query Language** ბაზასთან კომუნიკაციაში გამოიყენება. ANSI-ის დაყრდნობით ის არის სტანდარტული ენა რელაციურ მონაცემთა ბაზის მართვითი სისტემებისთვის. SQL ბრძანებების მეშვეობით
ხდება მონაცემთა ბაზის განახლება ან ბაზიდან ინფორმაციის ამოღება. ამ ბრძანებებს აქვთ მათთვის განსაზღვრული სინტაქსი. ხშირად გამოყენებადი SQL ბაზებია: PostgreSQL, Oracle, MySQL, SQLite და ა.შ. პითონისა და ფლასკის დაკავშირება საკამოდ იოლია ამ ბაზებთან,
რადგან ისინი უკვე არიან აღჭურვილნი მარტივ გამოყენებადი, ძლიერი იარაღებით, ბაზებთან სამუშაოდ.

Ბაზაში ცხრილის შექმნისთვის საჭირო ძირითადი საფეხურები:
1. Ცხრილის დასახელბა
2. Ცხრილში შესატანი მონაცემების სვეტებად დაყოფა
3. Სვეტების დასახელება
4. Სვეტებში მოსათავსებელი მონაცემის ტიპის გაწერა

### სინტაქსის გამოყენების მაგალითი

Ცხრილ “users” -ში არსებული ინფორმაციის ვიზუალიზაცია.
Ამოღებულია ინსტრუქციით:
```sql
SELECT * FROM users;
```
Ამ ენას მალე უკეთ გავეცნობით

![select](select.png)

_`*` - wildcard, გამოიყენება ერთი ან მეტი სიმბოლოს ჩასანაცვლებლად._

## SQLite
მონაცემთა ბაზასთან ურთიერთობას დავიწყებთ SQLite-ს გამოყენებით. 

![sqlite](https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/SQLite370.svg/382px-SQLite370.svg.png)

SQLite არის C-ს ბიბლიოთეკა, რომელიც წარმოადგენს მსუბუქ disk-based მონაცემთა საცავს. ანუ მას არ სჭირდება ცალკე სერვერის პროცესები ფუნქციონირებისთვის.
SQLite ხშირად გამოიყენება პროექტის მოდელირებისთვის, მონაცემის ლოკალური საცავისთვის ან მსუბუქი დატვირთვის ვებ სერვისზე (100,000 მიმოცვლა დღეში).

სიტყვა *lite* - მსუბუქი, SQLite-ში ამავე მნიშვნელობით გამოიყენება, რადგან SQLite-ის ბზები არის მარტივი ასაწყობი, სამართავი და მოითხოვს მცირე რესურს, რაც შესასრულებელ სამუშაოს ხშირად ამსუბუქებს. ამის გამო SQLite-ს ბაზები გამოიყენება როგორც პროტოტიპირებისას, ასევე დასრულებულ, გაშვებულ პროდუქტში, რომლის საჭიროებებსაც ამგვარი ბაზები აკმაყოფილებენ.

_self-contained, serverless, zero-configuration, transactional._

### მონაცემთა ტიპები

მონაცემთა ბაზები, როგორიც არის MySQL ან PostgreSQL, ძირითად შემთხვევაში იყენებენ მონაცემთა *სტატიკურ ტიპებს*. ეს გულისხმობს, რომ თუ ბაზაში ცხრილის შექმნისას სვეტს მივაკუთნებთ გარკვეულ ტიპს (მაგ. integer, float), მონაცემი რომელიც ამ სვეტის ქვეშ განთავსდება შეზღუდულია მიკუთვნებული ტიპით. შესაბამისად ინტეჯერ ტიპის სვეტში შესაძლებელია მოხვდეს მხოლოდ და მხოლოდ ინტეჯერ ტიპის მონაცემი.

განსხვავებით სხვა ბაზებისგან SQLite იყენებს მონაცემთა *დინამიურ ტიპებს*. რაც გულისხმობს რომ, ნებისმიერ სვეტში შენახული მონაცემის ტიპი განპირობებულია *მხოლოდ და მხოლოდ კონკრეტულად შენახული მონაცემის ტიპით*, და არა სვეტის ტიპით რომლის ქვეშაც მოთავსებულია ეს მონაცემი. 

აქედან გამომდინარე, SQLite არ მოითხოვს სვეტის შექმნისას, მასში მოსათავსებელი მონაცემის ტიპის წინასწარ გაწერას და აქედან გამომდინარე, წინასწარ გაწერილი მონაცემის ტიპის სვეტში შესაძლებელია განსხვავებული ტიპის მონაცემის შენახვაც.

SQLite გვთავაზობს 5 პირობით მონაცემთა ტიპს, რომელსაც *მეხსიერებათა კლასებს* უწოდებენ - storage classes

![SQLITE მეხსიერებათა კლასები](https://docplayer.net/docs-images/63/49185735/images/11-2.jpg)

## Python და SQLite 

პითონთან სამუშაოდ გამოვიყენებთ Gerhard Häring-ის მიერ შექმნილ მოდულს sqlite3. 
მოდულის გამოსაყენებლად უნდა შევქმნათ დამაკავშირებელი ობიექტი connection, რომელიც წარმოადგენს sqlite მონაცემთა ბაზას. ამისთვის უნდა შემოვიტანოთ sqlite3-ის მოდელი და შესაბამის მაკავშირებელს ობიექტს უნდა გადავცეთ ბაზის მონაცემი, ჩვენს შემთხვევაში დასახელება.

```python
import sqlite3
conn = sqlite3.connect('mydata.db')
```

ამრიგად პროგრამის გაშვების ადგილას შეიქმნება ახალი ფაილი mydata.db, რომელიც უკვე მზად არის გამოსაყენებლად დამატებითი საფეხურების გარეშე.

მას შემდეგ რაც შევქმნით მაკავშირებელ ობიექტს conn, ჩვენ შეგვიძლია მისგან ავიღოთ კურსორის ობიექტი, რომლის execute() მეთოდის გამოყენებითაც შევძლებთ მონაცემთა ბაზაზე SQL ბრძანებების შესრულებას, მეთოდისთვის შესაბამისი პარამეტრების გადაცემით.

პროგრამულად ბაზაში ახალი ცხრილის და მასში მონაცემის დამატების პროცესი ასე გამოიყურება:

```python
# ვქმნით კურსორს
cursor = conn.cursor()

# ვქმნით ცხრილს
cursor.execute('''CREATE TABLE წიგნები
             (თარიღი text, ავტორი text, დასახელება text, ტირაჟი real, ფასი real)''')

# ვამატებთ წიგნს როგორც მონაცემს
cursor.execute("INSERT INTO წიგნები VALUES ('2017-04-27','დათო სამნიაშვილი','MOX (მოქსი)',100,9.50)")

# ვინახავთ (commit) ცვლილებებს
conn.commit()

# პროცესის დასრულების შემდგომ ვხურავთ კავშირს
conn.close()
```

გაითვალისწინეთ, ისეთ შემთხვევაში სადაც ბრძანება ბაზაში მონაცემის ჩაწერას, ან შეცვლას მოითხოვს აუცილებელია commit() მეთოდის გამოყენება, წინააღმდეგ შემთხვევაში, პროცედურის დასრულების შემდგომ ბაზაზე შესრულებული ცვლილება არ აისახება.

### პარამეტრების გადაცემა

შესასრული სამუშაოების ავტომატიზაციისათვის, წინასწარ უნდა გავამზადოთ ბაზასთან გადასაცემი ბრძანებების შაბლონები. ამ ბრძანებებს შეგვიძლია გავატანოთ ცვლადებში შენახული პარამეტრები. პარამეტრების შაბლონურ სტრინგში ჩასმა შესაძლებელია სტრინგ ფორმატინგით, თუმცა ეს არც ისე უსაფრთხო და არარეკომენდირებული მეთოდია. 

```python
# არ გამოიყენოთ მსგავსი მეთოდ -- არ არის სანდო!
parameters = 'MOX (მოქსი)'
cursor.execute("SELECT * FROM წიგნები WHERE დასახელება = '%s'" % parameters)
```

ამის მაგივრად execute() მეთოდს, SQL ინსტრუქციასთან ერთად უნდა გადავცეთ შესაბამის ცვლადში მოთავსებული პარამეტრები, SQL ინსტრუქციაში კი ცვლადის ადგილას მივუთითებთ "?" ნიშნით. ცვლადის ტიპი რომელსაც შემსრულებელ მეთოდს გადავცემთ, მიუხედავად იმისა ერთი თუ რამოდენიმე წევრისაგან შედგება ეს პარამეტრი უნდა იყოს tuple. მაგალითად parameters = ('დათო სამნიაშვილი',)

```python
# ერთი პარამეტრის შემთხვევაში
parameters = ('MOX (მოქსი)',)
cursor.execute('SELECT * FROM წიგნები WHERE დასახელება=?', parameters)

# რამოდენიმე პარამეტრის შემთხვევაში
parameters = ('MOX (მოქსი)','დათო სამნიაშვილი')
cursor.execute('SELECT * FROM წიგნები WHERE დასახელება=?, ავტორი=?', parameters)
```

ამავდროულად, ერთი მეთოდით executemany() შეგვიძლია რამოდენიმე მონაცემის ერთდროულად შეტანა/დამუშავება. მაგალითად:

```python
books = [('2017-01-27','ზურა ჯიშკარიანი','საღეჭი განთიადები: უშაქროდ',1000,9.50),
         ('2017-04-27','დათო სამნიაშვილი','MOX (მოქსი)',1000,9.50),
         ('1875-04-06', 'ჟიულ ვერნი', 'საიდუმლო კუნძული', 1000,9.50),
        ]
cursor.executemany('INSERT INTO წიგნები VALUES (?,?,?,?,?)', books)
```

--- ჩაამატე fetchall, fetchone ---

ბაზაში მონაცემის განსანახლებლად ვიყენებთ შემდეგი ტიპის ინსტრუქციას:

```sqlite
UPDATE წიგნები SET დასახელება=? WHERE ავტორი=?
```

წასაშლელად:

```sqlite
"DELETE FROM წიგნები WHERE დასახელება=?"
```

## Flask და მონაცემთა ბაზა
იმისთვის რომ Flask აპლიკაციაში მონაცემთა ბაზის ჩაშენება შევძლოთ დაგვჭირდება 3 ძირითადი საფეხურის გავლა:
1. [Flask-ის კონფიგურირება მონაცემთა ბაზისთვის](#flask-აპლიკაციის-გამართვა)
2. [ბაზის მოდელის აწყობა ფლასკში](#ბაზის-მოდელის-აწყობა)
3. ბაზის მოდელზე ვებ რესურსის მორგება

### მინიმალური მაგალითი
```python
import os #გამოვიყენებთ რესურსების მისამართებთან სამუშაოდ
from flask import Flask
from flask_sqlalchemy import SQLAlchemy

basedir = os.path.abspath(os.path.dirname(__file__))

app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)


class NameModel(db.Model):
    # დეფოლტ მნიშვნელობად ცხრილს დაერქმევა კლასის სახელი.
    # __tablename__ = "name_of_table" # მოხსენი კომენტარი თუ გინდა რაიმე განსხვავებულის დარქმევა ცხრილისთვის და გადაეცი სტრინგად

    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String)
    email = db.Column(db.String)

    def __init__(self, username, email):
        self.email = email
        self.username = username

    def __repr__(self):
        return f'email of {username} is {email}'

```

### flask აპლიკაციის გამართვა
დავიწყოთ მუშაობა [**Flask-SQLAlchemy**](https://flask-sqlalchemy.palletsprojects.com/en/2.x/quickstart/) -ში.

Flask-SQLAlchemy არის Flask-ის დამატებითი ბიბლიოთეკა, რომელიც ჩვენს პროექტს დააშენებს SQLAlchemy-ს შესაძლებლობებს.
მონაცემთა ბაზასთან სამუშაოდ საკმარისია flask-ის აპლიკაციის კონფიგურაციაში მონაცემთა ბაზის მისამართის მითითება და ამ აპლიკაციით SQLAlchemy ობიექტის შექმნა.
დასაწყებად დავაყენოთ ბიბლიოთეკა: `pip install -U Flask-SQLAlchemy`
![FlaskAlchemy](https://flask-sqlalchemy.palletsprojects.com/en/2.x/_images/flask-sqlalchemy-title.png)

იმისთვის რომ შევძლოთ ჩვენს სერვისში ბაზის გამოყენება, უნდა შევქმნათ flask აპლიკაცია შესაბამისი კონფიგურაციით. ამისთვის რამოდენიმე მარტივი ნაბიჯის გავლა დაგვჭირდება:
1. შევქმნათ Flask app
2. დავამატოთ აპლიკაციას SQLAlchemy-ს კონფიგურაცია
3. გადავცეთ ჩვენი აპლიკაცია SQLAlchemy-ს კლასის გამოძახებისას.

ფლესკ აპლიკაციის შექმნის საფეხური შეგიძლიათ ნახოთ მეხუთე თავში. SQLAlchemy-ს კონფიგურაცია მსგავსი პროცედურაა როგორც საიდუმლო სიტყვის დამატება ფლასკში.
რაც შეეხებათ მოდელებს, ისინი პირდაპირი ბმები არიან მონაცემთა ბაზის ცხრილებსა და კოდს შორის. პითონის კოდში შექმნილი ბაზის მოდელი აღწერს როგორი იქნება რეალური ცხრილი მონაცემთა ბაზაში.
შესაბამისად კოდიდან შევძლებთ ავტომატურად ცხრილის შექმნას, ამ ცხრილის შესაბამისი ბაზის მოდელის გაწერით, პითონი კი მუშაობისას ავტომატურად დააგენერირებს ბაზაში შესაბამის ცხრილებს.

ამიტომ წარმოიდგინეთ ფლასკ აპლიკაციაში მოდელის ხსენებისას რომ რეალურად ვგულისხმობთ ცხრილს რომელიც ამ მოდელის უკან დგას.
როგორც ვახსნეთ მოდელის აწყობა ხდება კოდში შესაბამისი კლასის გაწერით. ამ კლასს მოდელის შესაძლებლობებს ფლასკის ბიბლიოთეკიდან ამოღებული Model-ის მემკვიდრეობა აძლევს.

#### გავმართოთ აპლიკაცია
აპლიკაციის გასამართად რამოდენიმე იმპორტი დაგვჭირდება:
```python
import os #გამოვიყენებთ რესურსების მისამართებთან სამუშაოდ
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
```
ბაზის დირექტორიის მისამართის ამოსაღებად გამოვიყენებთ os ბიბლიოთეკას.
```python
basedir = os.path.abspath(os.path.dirname(__file__))
```
როდესაც პითონში იტვირთება რაიმე მოდელი, პითონში ჩაშენებული `__file__` იღებს ფაილის დასახელების მნიშვნელობას. 
`os.path.dirname(__file__)` გვაცლევს ინფორმაციას დირექტორიაზე რომელშიც ეს ფაილია მოთავსებული.
`os.path.abspath()` კი მაძლევს სრულ მისამართს რომელიც პროგრამის ფაილს გააჩნია.

შევქმნათ აპლიკაციის ობიექტი რომელსაც ბაზასთან დავაკავშირებთ:
````python
app = Flask(__name__)
app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///' + os.path.join(basedir, 'data.sqlite')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False

db = SQLAlchemy(app)
````
ეს ოთხი ხაზია საკმარისი ჩვენს აპლიკაციაში მონაცემთა ბაზის შემოსატანად და გასამართად.

db-ში მოთავსებულია ამ აპლიკაციის ბაზის ობიექტი, რომელშიც არის ჩვენს აპლიკაციაში გამოყენებადი ყველა ხელსაწყო რასაც SQLAlchemy გვთავაზობს.

ერთ-ერთი მათგანია Model. მისი დახმარებით შევძლებთ ავაწყოთ ბაზის მოდელი და შევძლოთ პითონის კოდიდან ბაზის მართვა.

### [ბაზის მოდელის აწყობა](https://flask-sqlalchemy.palletsprojects.com/en/2.x/models/#simple-example)
1. შექმენი მოდელის კლასი
2. ნათესაობითობა db.Model-ისგან
3. სურვილისამებრ გადაეცით ცხრილის სახელი
4. კლასს ატრიბუტებად დაურთეთ ცხრილის სვეტები (დასახელება, აღწერა)
5. ჩაამატეთ `__init__` და `__repr__` მეთოდები

შესაბამისად შევქმნათ მოდელის კლასი, და გადავცეთ მემკვიდრეობით წინა საფეხურში შექმნილი ბაზის მოდელის თვისებები.

````python
class NameModel(db.Model):
    # დეფოლტ მნიშვნელობად ცხრილს დაერქმევა კლასის სახელი. 
    # __tablename__ = "name_of_table" # მოხსენი კომენტარი თუ გინდა რაიმე განსხვავებულის დარქმევა ცხრილისთვის და გადაეცი სტრინგად
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String)
    email = db.Column(db.String)
````
სვეტების არწერა მოდელში ხდება კლასის ატრიბუტებად. ცხრილში თითოეული სვეტი შეესაბამება მოდელში გაწერილ თითოეულ ბაზის ატრიბუტს.
როგორც შევთანხმდით ბაზის ცხრილის სვეტის აღწერისას გვჭირდება მასში შემავალი მონაცემთა ტიპის გაწერა. SQLAlchemy-ს შემოთავაზებული ძირითადი მონაცემთა ტიპები:

ტიპი | აღწერა
---|---
Integer|მთელი რიცხვები
String(size)|ტექსტი მაქსიმალური ზომის ლიმიტით  (ზოგი ტიპის ბაზებთან სამუშაოდ არ არის აუცილებელი)
Text|დიდი ზომის ტექსტი
DateTime|თარიღი აღებული datetime ობიექტიდან.
Float|წილადი
Boolean|ბულიანი (ჭეშმარიტი/მცდარი)

ამის შემდეგ აუცილებელია init მეთოდის გაწერა, რომ შევძლოთ ამ ბაზის მოდელის ობიექტის შექმნა კოდში გამოსაყენებლად.

```python
    def __init__(self, username, email):
        self.email = email 
        self.username = username
```

ამრიგად მოდელის ატრიბუტები მიიღებენ იმ მნიშვნელობას რომელსაც მათ ობიექტის შექმნისას მივანიჭებთ. მოდელის სტრინგ რეპრეზენტაცია შემდეგნაირად შეგვიძლია გავწეროთ:

```python
    def __repr__(self):
        return f'email of {username} is {email}'
```

### ბაზის გაწყობა

შევქმნათ ახალი პითონის ფაილი `setupdatabase.py` სადაც შემოვიტანთ წინა თავში შექმნილ ბაზას `db` და მოდელს.

```python
from basic import db, NameModel

```

შევქმნათ ფუნქციონალი რომელიც ავტომატურად შექმნის ბაზას და მოათავსებს მასში ცხრილებს ბაზის მოდელის მიხედვით `create_all()` მეთოდის გამოყენებით.

```python
db.create_all()
```

ამის შემდეგ შესაძლებლობა გვაქვს შევქმნათ ობიექტები ბაზის მოდელის მიხედვით და დავამატოთ ისინი ბაზაში:

```python
# შევქმნათ ბაზის ახალი წევრები
user1 = NameModel('username1','user1@mail.com')
user2 = NameModel('username2','user2@mail.com')

# შევამოწმოთ თითოეული მომხმარებლის id ბაზაში
print(user1.id)
print(user2.id)

# დავამატოთ მონაცემები ბაზაში
db.session.add_all([user1,user2])

# ან ინდივიდუალური დამატებისას
# db.session.add(user1)
# db.session.add(user2)

# და ავსახოთ ცვლილებები ბაზაზე
db.session.commit()

# შევამოწმოთ id თავიდან
print(user1.id)
print(user2.id)
```
