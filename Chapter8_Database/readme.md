# მონაცემთა საცავი 
ამ თავში გავივლით შესავალს მონაცემთა ბაზებში პითონის გამოყენებით და ვნახავთ როგორ დავაკავშიროთ ბაზა Flask-ის აპლიკაციასთან

## სარჩევი
- [შესავალი](#შესავალი)
    - [SQL - Structured Query Language](#sql)
    - [ცხრილები](#ცხრილები)
- [SQLite3](#sqlite)
## შესავალი
ამ ეტაპისთვის უკვე ვიცით თუ როგორ შეგვიძლია მომხმარებლისგან ავიღოთ და დავამუშავოთ მონაცემები. ახლა ჩვენი მიზანია ვისწავლოთ
როგორ შეიძლება მონაცემებს სტრუქტურიზაცია და შენახვა.

Მონაცემთა ბაზა (database) არის ინფორმაციის მოწესრიგებული, დალაგებული კრებული, რომელში შემავალი მონაცემების მართვა, წაკითხვა, ამოღება, დამატება და განახლება გვეხმარება მარტივად გავზარდოთ ჩვენი პროგრამის ფუნქციონალური შესაძლებლობები. 

მონაცემთა ბაზა არის საცავი, დახარისხებული ინფორმაციის საწყობი. არსებობს მონაცემთა ბაზის სხვადასხვა ტიპი, თუმცა ჩვენი სწორება იქნება რელაციურ SQL ტიპის მონაცემთა ბაზაზე.

**Რელაციური მონაცემთა ბაზა** არის მონაცემთა ბაზის ერთ-ერთი ტიპი. Მასში იმფორმაცია ისეა დალაგებული რომ მარტივად შევძლოთ მონაცემის იდენტიფიცირება და მასზე წვდომა, მასში შემავალ მონაცემთან მიმართებაში. 
Ხშირ შემთხვევაში, რელაციური ბაზაში, მონაცემები ინახება ცხრილების სახით.

### ცხრილები
ცხრილი არის ერთეული ობიექტი რომელიც ინახავს მონაცემს რელაციურ მონაცემთა საცავში. მონაცემთა საცავი შეიძლება მოიცავდეს ერთ ან მეტ ცხრილს.

ცხრილი კი თავის თავში შედგება სვეტებისა და სტრიქონებისგან (columns/rows). ყოველ სტრიქონს აქვს განსაზღვრული დასახელება და ინფორმაციის ტიპი
რომელიც მის გასწვრივ სტრიქონებში განთავსდება.

![ცხრილი](https://www.sqlshack.com/wp-content/uploads/2020/07/anatomy-of-a-sql-table-1.png)

სურათზე არის რელაციური SQL ბაზის მარტივი მაგალითი, სადაც ცხრილი **Persons** შედგება **Id**, **Name**, **SurName** და **age** სვეტებისგან. სვეტებში შემავალი ინფორმაცია, განლაგებული მწკრივბად განსხვავდება შიგთავსითა და ტიპი, ზოგიერთი მათგან ტექსტური, ხოლო ზოგი რიცხვითი სახისაა.

### SQL 
**Structured Query Language** ბაზასთან კომუნიკაციაში გამოიყენება. ANSI-ის დაყრდნობით ის არის სტანდარტული ენა რელაციურ მონაცემთა ბაზის მართვითი სისტემებისთვის. SQL ბრძანებების მეშვეობით
ხდება მონაცემთა ბაზის განახლება ან ბაზიდან ინფორმაციის ამოღება. ამ ბრძანებებს აქვთ მათთვის განსაზღვრული სინტაქსი. ხშირად გამოყენებადი SQL ბაზებია: PostgreSQL, Oracle, MySQL, SQLite და ა.შ. პითონისა და ფლასკის დაკავშირება საკამოდ იოლია ამ ბაზებთან,
რადგან ისინი უკვე არიან აღჭურვილნი მარტივ გამოყენებადი, ძლიერი იარაღებით, ბაზებთან სამუშაოდ.

Ბაზაში ცხრილის შექმნისთვის საჭირო ძირითადი საფეხურები:
1. Ცხრილის დასახელბა
2. Ცხრილში შესატანი მონაცემების სვეტებად დაყოფა
3. Სვეტების დასახელება
4. Სვეტებში მოსათავსებელი მონაცემის ტიპის გაწერა

### სინტაქსის გამოყენების მაგალითი

Ცხრილ “users” -ში არსებული ინფორმაციის ვიზუალიზაცია.
Ამოღებულია ინსტრუქციით:
```sql
SELECT * FROM users;
```
Ამ ენას მალე უკეთ გავეცნობით

![select](select.png)

_`*` - wildcard, გამოიყენება ერთი ან მეტი სიმბოლოს ჩასანაცვლებლად._

## SQLite
მონაცემთა ბაზასთან ურთიერთობას დავიწყებთ SQLite-ს გამოყენებით. 

SQLite არის C-ს ბიბლიოთეკა, რომელიც წარმოადგენს მსუბუქ disk-based მონაცემთა საცავს. ანუ მას არ სჭირდება ცალკე სერვერის პროცესები ფუნქციონირებისთვის.
SQLite ხშირად გამოიყენება პროექტის მოდელირებისთვის, მონაცემის ლოკალური საცავისთვის ან მსუბუქი დატვირთვის ვებ სერვისზე (100,000 მიმოცვლა დღეში).

სიტყვა *lite* - მსუბუქი, SQLite-ში ამავე მნიშვნელობით გამოიყენება, რადგან SQLite-ის ბზები არის მარტივი ასაწყობი, სამართავი და მოითხოვს მცირე რესურს, რაც შესასრულებელ სამუშაოს ხშირად ამსუბუქებს. ამის გამო SQLite-ს ბაზები გამოიყენება როგორც პროტოტიპირებისას, ასევე დასრულებულ, გაშვებულ პროდუქტში, რომლის საჭიროებებსაც ამგვარი ბაზები აკმაყოფილებენ.

_self-contained, serverless, zero-configuration, transactional._

### მონაცემთა ტიპები

მონაცემთა ბაზები, როგორიც არის MySQL ან PostgreSQL, ძირითად შემთხვევაში იყენებენ მონაცემთა *სტატიკურ ტიპებს*. ეს გულისხმობს, რომ თუ ბაზაში ცხრილის შექმნისას სვეტს მივაკუთნებთ გარკვეულ ტიპს (მაგ. integer, float), მონაცემი რომელიც ამ სვეტის ქვეშ განთავსდება შეზღუდულია მიკუთვნებული ტიპით. შესაბამისად ინტეჯერ ტიპის სვეტში შესაძლებელია მოხვდეს მხოლოდ და მხოლოდ ინტეჯერ ტიპის მონაცემი.

განსხვავებით სხვა ბაზებისგან SQLite იყენებს მონაცემთა *დინამიურ ტიპებს*. რაც გულისხმობს რომ, ნებისმიერ სვეტში შენახული მონაცემის ტიპი განპირობებულია *მხოლოდ და მხოლოდ კონკრეტულად შენახული მონაცემის ტიპით*, და არა სვეტის ტიპით რომლის ქვეშაც მოთავსებულია ეს მონაცემი. 

აქედან გამომდინარე, SQLite არ მოითხოვს სვეტის შექმნისას, მასში მოსათავსებელი მონაცემის ტიპის წინასწარ გაწერას და აქედან გამომდინარე, წინასწარ გაწერილი მონაცემის ტიპის სვეტში შესაძლებელია განსხვავებული ტიპის მონაცემის შენახვაც.

SQLite გვთავაზობს 5 პირობით მონაცემთა ტიპს, რომელსაც *მეხსიერებათა კლასებს* უწოდებენ - storage classes

![SQLITE მეხსიერებათა კლასები](https://docplayer.net/docs-images/63/49185735/images/11-2.jpg)

## Python და SQLite 

პითონთან სამუშაოდ გამოვიყენებთ Gerhard Häring-ის მიერ შექმნილ მოდულს sqlite3. 
მოდულის გამოსაყენებლად უნდა შევქმნათ დამაკავშირებელი ობიექტი connection, რომელიც წარმოადგენს sqlite მონაცემთა ბაზას. ამისთვის უნდა შემოვიტანოთ sqlite3-ის მოდელი და შესაბამის მაკავშირებელს ობიექტს უნდა გადავცეთ ბაზის მონაცემი, ჩვენს შემთხვევაში დასახელება.

```python
import sqlite3
conn = sqlite3.connect('mydata.db')
```

ამრიგად პროგრამის გაშვების ადგილას შეიქმნება ახალი ფაილი mydata.db, რომელიც უკვე მზად არის გამოსაყენებლად დამატებითი საფეხურების გარეშე.

მას შემდეგ რაც შევქმნით მაკავშირებელ ობიექტს conn, ჩვენ შეგვიძლია მისგან ავიღოთ კურსორის ობიექტი, რომლის execute() მეთოდის გამოყენებითაც შევძლებთ მონაცემთა ბაზაზე SQL ბრძანებების შესრულებას, მეთოდისთვის შესაბამისი პარამეტრების გადაცემით.

პროგრამულად ბაზაში ახალი ცხრილის და მასში მონაცემის დამატების პროცესი ასე გამოიყურება:

```python
# ვქმნით კურსორს
cursor = conn.cursor()

# ვქმნით ცხრილს
cursor.execute('''CREATE TABLE წიგნები
             (თარიღი text, ავტორი text, დასახელება text, ტირაჟი real, ფასი real)''')

# ვამატებთ წიგნს როგორც მონაცემს
cursor.execute("INSERT INTO წიგნები VALUES ('2017-04-27','დათო სამნიაშვილი','MOX (მოქსი)',100,9.50)")

# ვინახავთ (commit) ცვლილებებს
conn.commit()

# პროცესის დასრულების შემდგომ ვხურავთ კავშირს
conn.close()
```

გაითვალისწინეთ, ისეთ შემთხვევაში სადაც ბრძანება ბაზაში მონაცემის ჩაწერას, ან შეცვლას მოითხოვს აუცილებელია commit() მეთოდის გამოყენება, წინააღმდეგ შემთხვევაში, პროცედურის დასრულების შემდგომ ბაზაზე შესრულებული ცვლილება არ აისახება.

### პარამეტრების გადაცემა

შესასრული სამუშაოების ავტომატიზაციისათვის, წინასწარ უნდა გავამზადოთ ბაზასთან გადასაცემი ბრძანებების შაბლონები. ამ ბრძანებებს შეგვიძლია გავატანოთ ცვლადებში შენახული პარამეტრები. პარამეტრების შაბლონურ სტრინგში ჩასმა შესაძლებელია სტრინგ ფორმატინგით, თუმცა ეს არც ისე უსაფრთხო და არარეკომენდირებული მეთოდია. 

```python
# არ გამოიყენოთ მსგავსი მეთოდ -- არ არის სანდო!
parameters = 'MOX (მოქსი)'
cursor.execute("SELECT * FROM წიგნები WHERE დასახელება = '%s'" % parameters)
```

ამის მაგივრად execute() მეთოდს, SQL ინსტრუქციასთან ერთად უნდა გადავცეთ შესაბამის ცვლადში მოთავსებული პარამეტრები, SQL ინსტრუქციაში კი ცვლადის ადგილას მივუთითებთ "?" ნიშნით. ცვლადის ტიპი რომელსაც შემსრულებელ მეთოდს გადავცემთ, მიუხედავად იმისა ერთი თუ რამოდენიმე წევრისაგან შედგება ეს პარამეტრი უნდა იყოს tuple. მაგალითად parameters = ('დათო სამნიაშვილი',)

```python
# ერთი პარამეტრის შემთხვევაში
parameters = ('MOX (მოქსი)',)
cursor.execute('SELECT * FROM წიგნები WHERE დასახელება=?', parameters)

# რამოდენიმე პარამეტრის შემთხვევაში
parameters = ('MOX (მოქსი)','დათო სამნიაშვილი')
cursor.execute('SELECT * FROM წიგნები WHERE დასახელება=?, ავტორი=?', parameters)
```

ამავდროულად, ერთი მეთოდით executemany() შეგვიძლია რამოდენიმე მონაცემის ერთდროულად შეტანა/დამუშავება. მაგალითად:

```python
books = [('2017-01-27','ზურა ჯიშკარიანი','საღეჭი განთიადები: უშაქროდ',1000,9.50),
         ('2017-04-27','დათო სამნიაშვილი','MOX (მოქსი)',1000,9.50),
         ('1875-04-06', 'ჟიულ ვერნი', 'საიდუმლო კუნძული', 1000,9.50),
        ]
cursor.executemany('INSERT INTO წიგნები VALUES (?,?,?,?,?)', books)
```

ბაზაში მონაცემის განსანახლებლად ვიყენებთ შემდეგი ტიპის ინსტრუქციას:

```sqlite
UPDATE წიგნები SET დასახელება=? WHERE ავტორი=?
```

წასაშლელად:

```sqlite
"DELETE FROM წიგნები WHERE დასახელება=?"
```
